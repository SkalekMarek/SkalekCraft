<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Clone</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            user-select: none;
            font-family: Arial, sans-serif;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path d="M9 0h2v9h9v2h-9v9H9v-9H0V9h9z" fill="white" stroke="black" stroke-width="1"/></svg>') no-repeat center;
            transform: translate(-50%, -50%);
        }

        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 5px;
            transition: transform 0.1s;
        }

        .slot {
            width: 50px;
            height: 50px;
            border: 3px solid #555;
            margin: 0 3px;
            background-color: #888;
            image-rendering: pixelated;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            position: relative;
        }

        .active {
            border-color: white;
            transform: scale(1.1);
            z-index: 10;
        }

        .slot-number {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 10px;
            color: gold;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            pointer-events: none;
        }

        #block-count {
            position: absolute;
            top: 40px;
            left: 10px;
            color: #eee;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div id="crosshair"></div>
        <div id="hotbar">
            <!-- Slots will be filled by JS -->
        </div>
        <div id="info">WASD to Move | SPACE Jump/Swim | Click to Mine | 1-9 Select<br>Water Physics Enabled</div>
        <div id="block-count">Blocks: 0</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CLASSES ---

        class Player {
            constructor(camera, domElement, world) {
                this.camera = camera;
                this.world = world;
                this.controls = new PointerLockControls(camera, domElement);

                this.velocity = new THREE.Vector3();
                this.direction = new THREE.Vector3();
                this.input = { forward: false, backward: false, left: false, right: false, sprint: false, jump: false, down: false, crouch: false };
                this.canJump = false;
                this.isSwimming = false;
                this.headSubmerged = false;

                this.defaultHeight = 1.6;
                this.crouchHeight = 1.0;
                this.currentHeight = 1.6;
                this.wasCrouching = false;

                this.setupInputs();
            }

            setupInputs() {
                const onKeyDown = (event) => {
                    switch (event.code) {
                        case 'ArrowUp': case 'KeyW': this.input.forward = true; break;
                        case 'ArrowLeft': case 'KeyA': this.input.left = true; break;
                        case 'ArrowDown': case 'KeyS': this.input.backward = true; break;
                        case 'ArrowRight': case 'KeyD': this.input.right = true; break;
                        case 'Space':
                            this.input.jump = true;
                            if (this.canJump && !this.isSwimming) { this.velocity.y += 12; this.canJump = false; }
                            break;
                        case 'ShiftLeft': case 'ShiftRight':
                            this.input.sprint = true;
                            this.input.down = true;
                            break;
                        case 'ControlLeft': case 'KeyC':
                            this.input.crouch = true;
                            break;
                    }
                };
                const onKeyUp = (event) => {
                    switch (event.code) {
                        case 'ArrowUp': case 'KeyW': this.input.forward = false; break;
                        case 'ArrowLeft': case 'KeyA': this.input.left = false; break;
                        case 'ArrowDown': case 'KeyS': this.input.backward = false; break;
                        case 'ArrowRight': case 'KeyD': this.input.right = false; break;
                        case 'Space': this.input.jump = false; break;
                        case 'ShiftLeft': case 'ShiftRight':
                            this.input.sprint = false;
                            this.input.down = false;
                            break;
                        case 'ControlLeft': case 'KeyC':
                            this.input.crouch = false;
                            break;
                    }
                };
                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
                document.addEventListener('click', () => {
                    if (!this.controls.isLocked) this.controls.lock();
                });
            }

            update(delta) {
                if (!this.controls.isLocked) return;

                // Handle Un-Crouch Physics (Prevent getting stuck in floor)
                if (this.input.crouch !== this.wasCrouching) {
                    if (!this.input.crouch) {
                        // Standing up: Move camera UP so feet stay on ground
                        this.camera.position.y += (this.defaultHeight - this.crouchHeight);
                    }
                    this.wasCrouching = this.input.crouch;
                }

                // Check Environment
                this.checkIfInWater();

                // Toggle Water Visibility based on HEAD (visuals)
                if (this.world.mats && this.world.mats.waterSurface) {
                    const side = this.headSubmerged ? THREE.DoubleSide : THREE.DoubleSide;
                    // Actually we keep Surface as DoubleSide always now (from previous fix).
                    // But if we had logic to switch, it would depend on headSubmerged.
                    // Previous fix made waterSurface DoubleSide static. So we can ignore this.
                }

                // Crouching Logic
                const targetHeight = this.input.crouch ? this.crouchHeight : this.defaultHeight;
                // Smooth interpolation for height
                this.currentHeight += (targetHeight - this.currentHeight) * 10 * delta;

                // Constants vary by environment
                const friction = this.isSwimming ? 4.0 : 10.0;
                const gravity = this.isSwimming ? 5.0 : 30.0;
                let walkSpeed = 50.0;
                let runSpeed = 100.0;
                let crouchSpeed = 20.0;

                if (this.isSwimming) {
                    walkSpeed = 25.0;
                    runSpeed = 40.0;
                }

                // Drag/Friction
                this.velocity.x -= this.velocity.x * friction * delta;
                this.velocity.z -= this.velocity.z * friction * delta;

                // Gravity / Buoyancy
                if (this.isSwimming) {
                    // Buoyancy: slowly float up unless sinking
                    this.velocity.y -= this.velocity.y * friction * delta; // Water resistance vertical
                    if (this.input.jump) this.velocity.y += 15.0 * delta; // Swim up
                    else if (this.input.down) this.velocity.y -= 15.0 * delta; // Swim down
                    else this.velocity.y -= 2.0 * delta; // Slow drift down
                } else {
                    this.velocity.y -= gravity * delta;
                }

                // Input Movement
                this.direction.z = Number(this.input.forward) - Number(this.input.backward);
                this.direction.x = Number(this.input.right) - Number(this.input.left);
                this.direction.normalize();

                let speed = walkSpeed;
                if (this.input.sprint) speed = runSpeed;
                if (this.input.crouch) speed = crouchSpeed;

                if (this.input.forward || this.input.backward) this.velocity.z -= this.direction.z * speed * delta;
                if (this.input.left || this.input.right) this.velocity.x -= this.direction.x * speed * delta;

                // X/Z Movement + Collision
                this.controls.moveRight(-this.velocity.x * delta);
                if (this.checkCollision()) {
                    this.controls.moveRight(this.velocity.x * delta);
                    this.velocity.x = 0;
                }

                this.controls.moveForward(-this.velocity.z * delta);
                if (this.checkCollision()) {
                    this.controls.moveForward(this.velocity.z * delta);
                    this.velocity.z = 0;
                }

                // Y Movement
                this.camera.position.y += this.velocity.y * delta;

                if (this.checkCollision()) {
                    if (this.velocity.y < 0) { // Landing
                        this.camera.position.y -= this.velocity.y * delta;
                        this.velocity.y = 0;
                        this.canJump = true;
                    } else { // Ceiling
                        this.camera.position.y -= this.velocity.y * delta;
                        this.velocity.y = 0;
                    }
                }

                if (this.camera.position.y < -30) {
                    this.camera.position.set(0, 30, 0); // Respawn higher
                    this.velocity.set(0, 0, 0);
                }

                // Visuals: Only change fog if HEAD is submerged
                if (this.headSubmerged) {
                    this.world.scene.fog.color.setHex(0x001e0f);
                    this.world.scene.fog.near = 1;
                    this.world.scene.fog.far = 10;
                } else {
                    this.world.scene.fog.color.setHex(0x87CEEB);
                    this.world.scene.fog.near = 10;
                    this.world.scene.fog.far = 60;
                }

                // Dynamic FOV
                let targetFOV = 75;
                if (this.input.sprint) targetFOV = 95;
                if (this.input.crouch) targetFOV = 70;

                if (Math.abs(this.camera.fov - targetFOV) > 1) {
                    this.camera.fov += (targetFOV - this.camera.fov) * 5 * delta;
                    this.camera.updateProjectionMatrix();
                }
            }

            checkIfInWater() {
                const p = this.camera.position;

                // 1. Head Check (Visuals)
                const headType = this.world.getBlockType(Math.floor(p.x), Math.floor(p.y), Math.floor(p.z));
                this.headSubmerged = (headType === 'water');

                // 2. Feet Check (Physics)
                // Check slightly around feet to avoid glitching on edge
                const feetY = p.y - 1.5; // Feet level
                const feetType = this.world.getBlockType(Math.floor(p.x), Math.floor(feetY), Math.floor(p.z));
                this.isSwimming = (feetType === 'water');

                // If feet are in water, we are swimming.
                // This allows jumping out because even if head is air, feet are water -> physics = water -> Jump = Swim Up
            }

            checkCollision() {
                const p = this.camera.position;
                const r = 0.3; // radius
                const minX = Math.floor(p.x - r);
                const maxX = Math.floor(p.x + r);
                const minZ = Math.floor(p.z - r);
                const maxZ = Math.floor(p.z + r);

                // Dynamic collision height based on input?
                // We use visual smoothed height for camera, but collision should be instant?
                // Let's use currentHeight variable for now
                const height = this.input.crouch ? this.crouchHeight : this.defaultHeight;

                const minY = Math.floor(p.y - height); // Feet
                const maxY = Math.floor(p.y - 0.1); // Head

                for (let x = minX; x <= maxX; x++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        for (let y = minY; y <= maxY; y++) {
                            const type = this.world.getBlockType(x, y, z);
                            if (type && type !== 'water') { // Water is not solid
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
        }

        class Mob {
            constructor(world, type, textureName) {
                this.world = world;
                this.type = type;
                this.position = new THREE.Vector3(0, 10, 0);
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.timers = { move: 0 };
                this.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();

                this.group = new THREE.Group();

                let bodyColor = 0xffffff;
                if (type === 'pig') bodyColor = 0xFFC0CB;
                if (type === 'cow') bodyColor = 0x444444;
                if (type === 'sheep') bodyColor = 0xdddddd;

                const loader = new THREE.TextureLoader();
                const faceTex = loader.load(textureName);
                faceTex.magFilter = THREE.NearestFilter;

                const headMats = [
                    new THREE.MeshStandardMaterial({ color: bodyColor }),
                    new THREE.MeshStandardMaterial({ color: bodyColor }),
                    new THREE.MeshStandardMaterial({ color: bodyColor }),
                    new THREE.MeshStandardMaterial({ color: bodyColor }),
                    new THREE.MeshBasicMaterial({ map: faceTex }), // FIX: Basic material to ignore lighting/shadows
                    new THREE.MeshStandardMaterial({ color: bodyColor })
                ];

                const headGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                this.head = new THREE.Mesh(headGeo, headMats);
                this.head.position.set(0, 0.6, 0.4);
                this.group.add(this.head);

                const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor });
                this.body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.9), bodyMat);
                this.body.position.set(0, 0, -0.2);
                this.group.add(this.body);

                this.legs = [];
                const legGeo = new THREE.BoxGeometry(0.15, 0.4, 0.15);
                const positions = [
                    [-0.2, -0.4, 0.1], [0.2, -0.4, 0.1],
                    [-0.2, -0.4, -0.5], [0.2, -0.4, -0.5]
                ];

                positions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeo, bodyMat);
                    leg.position.set(...pos);
                    this.legs.push(leg);
                    this.group.add(leg);
                });

                this.world.scene.add(this.group);
            }

            update(delta) {
                const g = 30.0;
                this.velocity.y -= g * delta;

                this.timers.move -= delta;
                if (this.timers.move <= 0) {
                    this.timers.move = Math.random() * 3 + 1;
                    this.direction.set(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                    if (Math.random() < 0.3) this.direction.set(0, 0, 0);
                }

                const speed = 2.0;
                const move = this.direction.clone().multiplyScalar(speed * delta);

                this.position.add(this.velocity.clone().multiplyScalar(delta));
                this.position.add(move);

                // Simple Floor Collision
                const r = 0.5;
                const minX = Math.floor(this.position.x - r);
                const maxX = Math.floor(this.position.x + r);
                const minZ = Math.floor(this.position.z - r);
                const maxZ = Math.floor(this.position.z + r);

                // Check if blocked horizontally
                if (this.world.getBlock(Math.floor(this.position.x), Math.floor(this.position.y), Math.floor(this.position.z))) {
                    // Inside block
                    this.position.sub(move); // Undo move
                }

                // Floor
                let groundY = -100;
                for (let y = Math.floor(this.position.y + 1); y >= Math.floor(this.position.y - 2); y--) {
                    if (this.world.getBlock(Math.floor(this.position.x), y, Math.floor(this.position.z))) {
                        groundY = y + 1;
                        break;
                    }
                }

                if (this.position.y < groundY) {
                    this.position.y = groundY;
                    this.velocity.y = 0;
                }

                this.group.position.copy(this.position);

                if (this.direction.length() > 0.1) {
                    const angle = Math.atan2(this.direction.x, this.direction.z);
                    this.group.rotation.y = angle;
                }

                const time = performance.now() / 1000;
                if (this.direction.length() > 0.1) {
                    this.legs[0].rotation.x = Math.sin(time * 10) * 0.5;
                    this.legs[1].rotation.x = Math.sin(time * 10 + Math.PI) * 0.5;
                    this.legs[2].rotation.x = Math.sin(time * 10 + Math.PI) * 0.5;
                    this.legs[3].rotation.x = Math.sin(time * 10) * 0.5;
                }
            }
        }

        class World {
            constructor(scene) {
                this.scene = scene;
                this.blocks = new Map();
                this.cObjects = [];
                this.mobs = [];

                // Materials
                const createMat = (color) => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64; canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = color;
                    ctx.fillRect(0, 0, 64, 64);
                    // Noise
                    for (let i = 0; i < 400; i++) {
                        ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
                        ctx.fillRect(Math.floor(Math.random() * 64), Math.floor(Math.random() * 64), 2, 2);
                    }
                    const tex = new THREE.CanvasTexture(canvas);
                    tex.magFilter = THREE.NearestFilter;
                    return new THREE.MeshStandardMaterial({ map: tex });
                };

                this.mats = {
                    grass: createMat('#4CBB17'),
                    stone: createMat('#808080'),
                    dirt: createMat('#5C4033'),
                    wood: createMat('#4a3728'),
                    leaves: createMat('#2E8B57'),
                    sand: createMat('#F4A460'),
                    bedrock: createMat('#1a1a1a'),
                    // Water materials
                    waterSurface: new THREE.MeshStandardMaterial({
                        color: 0x244F99,
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.DoubleSide
                    }),
                    waterSide: new THREE.MeshStandardMaterial({
                        color: 0x244F99,
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.FrontSide
                    })
                };

                this.geo = new THREE.BoxGeometry(1, 1, 1);

                // Water Mesh System
                this.waterSurfaceMesh = null;
                this.waterSideMesh = null;
                this.waterUpdatePending = false;

                // Simulation
                setInterval(() => this.simulateWater(), 400);
            }

            updateMobs(delta) {
                this.mobs.forEach(m => m.update(delta));
            }

            getBlock(x, y, z) { return this.blocks.has(`${x},${y},${z}`); }
            getBlockType(x, y, z) { return this.blocks.get(`${x},${y},${z}`); }

            placeBlock(x, y, z, type) {
                if (this.getBlock(x, y, z)) {
                    const existing = this.getBlockType(x, y, z);
                    if (existing === 'water' && type !== 'water') {
                        this.blocks.set(`${x},${y},${z}`, type);
                        this.requestWaterUpdate();
                    } else {
                        return;
                    }
                } else {
                    this.blocks.set(`${x},${y},${z}`, type);
                }

                if (type === 'water') {
                    this.requestWaterUpdate();
                } else {
                    const mesh = new THREE.Mesh(this.geo, this.mats[type]);
                    mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
                    this.scene.add(mesh);
                    this.cObjects.push(mesh);
                    mesh.userData = { x, y, z, type };
                    this.requestWaterUpdate();
                }
                document.getElementById('block-count').innerText = `Blocks: ${this.blocks.size}`;
            }

            removeBlock(mesh) {
                if (mesh.userData && mesh.userData.type) {
                    const { x, y, z } = mesh.userData;
                    this.scene.remove(mesh);
                    this.cObjects = this.cObjects.filter(o => o !== mesh);
                    this.blocks.delete(`${x},${y},${z}`);
                    this.requestWaterUpdate();
                    document.getElementById('block-count').innerText = `Blocks: ${this.blocks.size}`;
                }
            }

            removeBlockAt(x, y, z) {
                if (this.getBlockType(x, y, z) === 'water') {
                    this.blocks.delete(`${x},${y},${z}`);
                    this.requestWaterUpdate();
                }
            }

            requestWaterUpdate() {
                if (!this.waterUpdatePending) {
                    this.waterUpdatePending = true;
                    requestAnimationFrame(() => this.updateWaterGeometry());
                }
            }

            updateWaterGeometry() {
                this.waterUpdatePending = false;

                const waterBlocks = [];
                for (const [key, type] of this.blocks) {
                    if (type === 'water') {
                        const parts = key.split(',').map(Number);
                        waterBlocks.push({ x: parts[0], y: parts[1], z: parts[2] });
                    }
                }

                // Cleanup
                if (this.waterSurfaceMesh) { this.scene.remove(this.waterSurfaceMesh); this.waterSurfaceMesh = null; }
                if (this.waterSideMesh) { this.scene.remove(this.waterSideMesh); this.waterSideMesh = null; }

                if (waterBlocks.length === 0) return;

                const surfaceVerts = [];
                const sideVerts = [];

                // Helper
                const addFace = (x, y, z, face, targetArray) => {
                    const X = x, Y = y, Z = z;
                    const X1 = x + 1, Y1 = y + 1, Z1 = z + 1;
                    let v = [];
                    if (face === 'px') {
                        v = [X1, Y, Z1, X1, Y, Z, X1, Y1, Z, X1, Y, Z1, X1, Y1, Z, X1, Y1, Z1];
                    } else if (face === 'nx') {
                        v = [X, Y, Z, X, Y, Z1, X, Y1, Z1, X, Y, Z, X, Y1, Z1, X, Y1, Z];
                    } else if (face === 'py') {
                        v = [X, Y1, Z1, X1, Y1, Z1, X1, Y1, Z, X, Y1, Z1, X1, Y1, Z, X, Y1, Z];
                    } else if (face === 'ny') {
                        v = [X, Y, Z, X1, Y, Z, X1, Y, Z1, X, Y, Z, X1, Y, Z1, X, Y, Z1];
                    } else if (face === 'pz') {
                        v = [X1, Y, Z1, X, Y, Z1, X, Y1, Z1, X1, Y, Z1, X, Y1, Z1, X1, Y1, Z1];
                    } else if (face === 'nz') {
                        v = [X, Y, Z, X1, Y, Z, X1, Y1, Z, X, Y, Z, X1, Y1, Z, X, Y1, Z];
                    }
                    targetArray.push(...v);
                };

                for (const b of waterBlocks) {
                    const { x, y, z } = b;
                    // Sides -> sideVerts (FrontSide)
                    if (!this.getBlock(x + 1, y, z)) addFace(x, y, z, 'px', sideVerts);
                    if (!this.getBlock(x - 1, y, z)) addFace(x, y, z, 'nx', sideVerts);
                    // Top/Bottom -> surfaceVerts (DoubleSide)
                    if (!this.getBlock(x, y + 1, z)) addFace(x, y, z, 'py', surfaceVerts);
                    if (!this.getBlock(x, y - 1, z)) addFace(x, y, z, 'ny', surfaceVerts);

                    if (!this.getBlock(x, y, z + 1)) addFace(x, y, z, 'pz', sideVerts);
                    if (!this.getBlock(x, y, z - 1)) addFace(x, y, z, 'nz', sideVerts);
                }

                // Create Mesh 1: Surface
                if (surfaceVerts.length > 0) {
                    const geo = new THREE.BufferGeometry();
                    geo.setAttribute('position', new THREE.Float32BufferAttribute(surfaceVerts, 3));
                    geo.computeVertexNormals();
                    this.waterSurfaceMesh = new THREE.Mesh(geo, this.mats.waterSurface);
                    this.scene.add(this.waterSurfaceMesh);
                }

                // Create Mesh 2: Sides
                if (sideVerts.length > 0) {
                    const geo = new THREE.BufferGeometry();
                    geo.setAttribute('position', new THREE.Float32BufferAttribute(sideVerts, 3));
                    geo.computeVertexNormals();
                    this.waterSideMesh = new THREE.Mesh(geo, this.mats.waterSide);
                    this.scene.add(this.waterSideMesh);
                }
            }

            simulateWater() {
                const updates = [];
                // Only spread if within bounds
                const limit = this.size / 2;

                for (const [key, type] of this.blocks) {
                    if (type !== 'water') continue;
                    const [x, y, z] = key.split(',').map(Number);

                    // Boundary check for source block (just in case)
                    if (Math.abs(x) >= limit || Math.abs(z) >= limit) continue;

                    // Rule 1: Flow Down
                    const below = `${x},${y - 1},${z}`;
                    if (!this.blocks.has(below)) {
                        // Check void limit
                        if (y > -20) updates.push({ key: below, x: x, y: y - 1, z: z });
                        continue;
                    }

                    // Rule 2: Flow Sideways
                    const neighbors = [
                        [x + 1, y, z], [x - 1, y, z], [x, y, z + 1], [x, y, z - 1]
                    ];

                    for (const n of neighbors) {
                        // Check Borders
                        if (n[0] < -limit || n[0] >= limit || n[2] < -limit || n[2] >= limit) continue;

                        const nKey = `${n[0]},${n[1]},${n[2]}`;
                        if (!this.blocks.has(nKey)) {
                            updates.push({ key: nKey, x: n[0], y: n[1], z: n[2] });
                        }
                    }
                }

                let changed = false;
                for (const u of updates) {
                    if (!this.blocks.has(u.key)) {
                        this.blocks.set(u.key, 'water');
                        changed = true;
                    }
                }

                if (changed) this.requestWaterUpdate();
            }

            generate(size = 50) {
                this.size = size; // Store size for borders
                const waterLevel = -1;

                // Generate Bedrock Floor
                for (let x = -size / 2; x < size / 2; x++) {
                    for (let z = -size / 2; z < size / 2; z++) {
                        this.placeBlock(x, -6, z, 'bedrock');
                    }
                }

                for (let x = -size / 2; x < size / 2; x++) {
                    for (let z = -size / 2; z < size / 2; z++) {
                        const noise = Math.sin(x * 0.1) + Math.cos(z * 0.1) * 0.5 + Math.sin(x * 0.3 + z * 0.2) * 0.5;
                        const h = Math.floor(noise * 3);

                        // Border Walls? (Optional, user just asked water not to flow out, simulation fix parses that)
                        // But let's add a bedrock wall maybe? No, let's stick to just containment.

                        for (let y = -5; y <= h; y++) {
                            let type = 'stone';
                            if (y === h) {
                                if (h <= waterLevel + 1) type = 'sand';
                                else type = 'grass';
                            }
                            else if (y > h - 3) type = 'dirt';
                            this.placeBlock(x, y, z, type);
                        }
                        for (let y = h + 1; y <= waterLevel; y++) {
                            this.blocks.set(`${x},${y},${z}`, 'water');
                        }

                        if (h > waterLevel && x % 5 === 0 && z % 5 === 0 && Math.random() > 0.3) {
                            if (this.getBlockType(x, h, z) === 'grass') {
                                const th = 3 + Math.floor(Math.random() * 3);
                                for (let i = 1; i <= th; i++) this.placeBlock(x, h + i, z, 'wood');
                                for (let lx = -1; lx <= 1; lx++) {
                                    for (let lz = -1; lz <= 1; lz++) {
                                        for (let ly = th; ly <= th + 1; ly++) {
                                            if (lx === 0 && lz === 0 && ly === th) continue;
                                            this.placeBlock(x + lx, h + ly, z + lz, 'leaves');
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                this.requestWaterUpdate();

                // Spawn Mobs
                const mobTypes = [
                    { t: 'pig', img: 'ceca.png' },
                    { t: 'cow', img: 'bohy.png' },
                    { t: 'sheep', img: 'kohoutek.png' }
                ];

                for (let i = 0; i < 12; i++) {
                    const x = Math.floor((Math.random() * size) - size / 2);
                    const z = Math.floor((Math.random() * size) - size / 2);
                    // Find High Y
                    let y = 10;
                    // Raycast down logic? Just spawn high and let gravity fall
                    const mobDef = mobTypes[i % 3];
                    const mob = new Mob(this, mobDef.t, mobDef.img);
                    mob.position.set(x, 20, z); // Fall from sky
                    this.mobs.push(mob);
                }
            }
        }

        // --- MAIN ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambient);
        const dir = new THREE.DirectionalLight(0xffffff, 0.6);
        dir.position.set(20, 50, 20);
        scene.add(dir);

        const world = new World(scene);
        world.generate(48);

        const player = new Player(camera, document.body, world);

        // UI
        const hotbar = document.getElementById('hotbar');
        const types = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'sand', 'water'];
        let selectedIndex = 0;

        for (let i = 0; i < 9; i++) {
            const div = document.createElement('div');
            div.className = 'slot' + (i === 0 ? ' active' : '');
            if (i < types.length) {
                div.style.backgroundColor = getComputedStyleColor(types[i]);
                div.dataset.type = types[i];
            }
            const num = document.createElement('div');
            num.className = 'slot-number';
            num.innerText = i + 1;
            div.appendChild(num);
            hotbar.appendChild(div);
        }

        function getComputedStyleColor(type) {
            if (type === 'grass') return '#4CBB17';
            if (type === 'dirt') return '#5C4033';
            if (type === 'stone') return '#808080';
            if (type === 'wood') return '#4a3728';
            if (type === 'leaves') return '#2E8B57';
            if (type === 'sand') return '#F4A460';
            if (type === 'water') return '#244F99';
            return '#333';
        }

        const updateHotbar = () => {
            const slots = document.querySelectorAll('.slot');
            slots.forEach((s, idx) => {
                if (idx === selectedIndex) s.classList.add('active');
                else s.classList.remove('active');
            });
        };

        document.addEventListener('keydown', (e) => {
            if (e.key >= '1' && e.key <= '9') {
                selectedIndex = parseInt(e.key) - 1;
                updateHotbar();
            }
        });
        document.addEventListener('wheel', (e) => {
            if (e.deltaY > 0) selectedIndex = (selectedIndex + 1) % 9;
            else selectedIndex = (selectedIndex - 1 + 9) % 9;
            updateHotbar();
        });

        // Interaction
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0, 0);

        window.addEventListener('mousedown', (e) => {
            if (!player.controls.isLocked) return;
            raycaster.setFromCamera(center, camera);
            let hit = null;
            const intersects = raycaster.intersectObjects(world.cObjects); // Solid

            if (intersects.length > 0) hit = intersects[0];

            // Water Raycast Check
            if (world.waterMesh) {
                const wHits = raycaster.intersectObject(world.waterMesh);
                // Simple Distance Check
                if (wHits.length > 0) {
                    if (!hit || wHits[0].distance < hit.distance) hit = wHits[0];
                }
            }

            if (hit && hit.distance < 6) {
                const isWaterHit = (hit.object === world.waterMesh || hit.object === world.waterSurfaceMesh || hit.object === world.waterSideMesh);

                if (e.button === 0) {
                    // Break
                    if (isWaterHit) {
                        const p = hit.point.clone().add(raycaster.ray.direction.clone().multiplyScalar(0.1));
                        world.removeBlockAt(Math.floor(p.x), Math.floor(p.y), Math.floor(p.z));
                    } else {
                        // Break solid
                        world.removeBlock(hit.object);
                    }
                } else if (e.button === 2) {
                    // Place
                    if (!isWaterHit) {
                        const norm = hit.face.normal;
                        const pos2 = hit.object.position.clone().add(norm);
                        const bx = Math.floor(pos2.x);
                        const by = Math.floor(pos2.y);
                        const bz = Math.floor(pos2.z);

                        // SAFETY CHECK: Do not place inside player
                        const pPos = player.camera.position;
                        const pX = Math.floor(pPos.x);
                        const pZ = Math.floor(pPos.z);
                        const pYHead = Math.floor(pPos.y);
                        const pYFeet = Math.floor(pPos.y - 1.0);

                        // Check overlap
                        if (bx === pX && bz === pZ && (by === pYHead || by === pYFeet)) {
                            return; // Blocked by player
                        }

                        const type = types[selectedIndex] || 'stone';
                        world.placeBlock(bx, by, bz, type);
                    }
                }
            }
        });

        let prev = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const delta = Math.min((now - prev) / 1000, 0.1);
            prev = now;

            player.update(delta);
            world.updateMobs(delta);
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>